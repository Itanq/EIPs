---
eip: 777
title: ERC777 代币（通证）标准
author: Jacques Dafflon <mail@0xjac.com>, Jordi Baylina <jordi@baylina.cat>, Thomas Shababi <tom@truelevel.io>
discussions-to: https://github.com/ethereum/EIPs/issues/777
status: Final
type: Standards Track
category: ERC
created: 2017-11-20
requires: 1820
---

## 简要说明

此EIP定义了ERC777 代币合约标准接口。

## 摘要

ERC777 与[ERC20]的向后兼容， 同时也定义了一些更高级的方法和代币进行交互。

如：*操作者（operators）* 可以代表另一个地址（合约或普通账户）发送代币， 以及 send/receive 加入了钩子函数（*hooks* ）让代币持有者可以有更多的控制。

ERC777 同样采用了 [ERC1820] 标准的优点，判断接受代币的地址是合约还是普通地址，并且判断合约是否兼容ERC777协议。

## 动机


标准尝试改进大家常用的 [ERC20] 代币标准。
ERC777标准的主要优点有：

1. 使用和发送以太相同的理念发送token，方法为：`send(dest, value, data)`.

2. 合约和普通地址都可以通过注册`tokensToSend` hook函数来控制和拒绝发送哪些token（拒绝发送通过在hook函数`tokensToSend` 里 `revert` 来实现）。
3. 合约和普通地址都可以通过注册`tokensReceived` hook函数来控制和拒绝接受哪些token（拒绝接受通过在hook函数`tokensReceived` 里 `revert` 来实现）。

4. `tokensReceived` 可以通过hook函数可以做到在一个交易里完成发送代币和通知合约接受代币，而不像 [ERC20] 必须通过两次调用（`approve`/`transferFrom`）来完成。

5. 持有者可以"授权"和"撤销"操作员（operators: 可以代表持有者发送代币）。
   这些操作员通常是（去中心化）交易所、支票处理机或自动支付系统。

1. 每个代币交易都包含 `data` 和 `operatorData` 字段， 可以分别传递来自持有者和操作员的数据。

2. 可以通过部署实现 `tokensReceived` 的代理合约来兼容没有实现`tokensReceived` 函数的地址。

## 规范

### ERC777Token (代币合约)

``` solidity
interface ERC777Token {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function totalSupply() external view returns (uint256);
    function balanceOf(address holder) external view returns (uint256);
    function granularity() external view returns (uint256);

    function defaultOperators() external view returns (address[] memory);
    function isOperatorFor(
        address operator,
        address holder
    ) external view returns (bool);
    function authorizeOperator(address operator) external;
    function revokeOperator(address operator) external;

    function send(address to, uint256 amount, bytes calldata data) external;
    function operatorSend(
        address from,
        address to,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    function burn(uint256 amount, bytes calldata data) external;
    function operatorBurn(
        address from,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    event Sent(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );
    event Minted(
        address indexed operator,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );
    event Burned(
        address indexed operator,
        address indexed from,
        uint256 amount,
        bytes data,
        bytes operatorData
    );
    event AuthorizedOperator(
        address indexed operator,
        address indexed holder
    );
    event RevokedOperator(address indexed operator, address indexed holder);
}
```

ERC777 合约必须实现上述接口，也必须遵守以下规范。
合约需要用自己的地址通过 [ERC1820] 标准注册 `ERC777Token` 接口。

> 注册方法是调用[ERC1820] 注册合约的 `setInterfaceImplementer` 方法，参数 _addr 及  _implementer 均是合约的地址，_interfaceHash 是 `ERC777Token` 的  `keccak256` 哈希值， 即`0xac7fbab5f54a3ca8194167523c6753bfeb96a445279294b6125b68cce2177054`


如果合约有一个开关来启用或禁用ERC777功能，每次触发开关时，代币合约必须相应地通过ERC1820注册或取消注册`ERC777Token`接口。

取消注册使用代币合约地址作为参数 `_addr` 、`ERC777Token`的`keccak256`哈希作为接口哈希及'0x0`作为实现者参数 `_implementer` 调用函数`setInterfaceImplementer`，
有关详细信息，请参阅[ERC1820]中的[为接口设置实现地址](https://learnblockchain.cn/docs/eips/eip-1820.html#为接口设置实现地址)

当和代币合约进行交互时，所有的数量和余额都是无符号整型 `uint256` 类型 。总是以18次方存储（ `decimals` 只能是 18），0.5个代币存储为 `500,000,000,000,000,000` (0.5&times;10<sup>18</sup>)
[ERC20]内部处理也是一样（不过decimals可为其他值），最小单位相当于 wei, 用户看见的币相当于 ether。


#### **视图函数**

以下视图函数必须实现：

##### **`name` 函数**

``` solidity
function name() external view returns (string memory)
```

返回代币名称，如： `"MyToken"`

* 接口ID： `06fdde03`
* 返回值：代币名称


##### **`symbol` 函数**

``` solidity
function symbol() external view returns (string memory)
```
返回代币的代号，如`"MYT"`

* 接口ID：`95d89b41`
* 返回值：代币的代号


##### **`totalSupply` 函数**

``` solidity
function totalSupply() external view returns (uint256)
```

返回代币总流通量。


*注意*: 总供应量必须是所有账号余额（`balanceOf`）之和。
*注意*: 总供应量必须等于所有挖出的币（ `Minted` 事件定义）减去销毁的币（`Burned`事件定义）

* 接口ID：`18160ddd`
* 返回值：代币总流通量


##### **`balanceOf` 函数**

``` solidity
function balanceOf(address holder) external view returns (uint256)
```

返回帐户（通过参数"holder"）的余额，余额 >=0 。


* 接口ID：`70a08231`
* 参数holder： 查询的账号
* 返回值： 在代币合约里对应账号余额


##### **`granularity` 函数**

``` solidity
function granularity() external view returns (uint256)
```

获得代币最小的划分粒度（基于内部单位的个数），最小的挖矿、发送及销毁粒度。

*granularity* 需要满足一下规则：

- *granularity* 必须在创建时设置

- *granularity* 任何时候不可以更改。

- *granularity* 必须大于等于1。

- 所有的余额必须是granularity的整数倍。

- 挖矿、发送及销毁数量必须是granularity的整数倍。

- 非*granularity*的整数倍的操作都需要 `revert` 。

*注意*: 大部分的代币应该是完全可切分的，如果没有特别的理由，这个函数应该返回1。

* 接口ID：`556f0dc7`
* 返回值： 最小的划分粒度


*注意*: `defaultOperators` 和 `isOperatorFor` 也是视图函数，他们在操作员部分定义。


**[ERC20] 兼容性需要**:

代币的 decimals 必须是 `18`。
对于一个 纯粹的 ERC777 代币 [ERC20] 的 `decimals` 函数是可选的，与合约交互的时候不应该依赖这个值（18是隐含值）。

为了兼容 [ERC20] 代币, `decimals` 函数要求必须返回18。 （因为在 [ERC20] 中`decimals` 是可选的，也没有明确的默认值，如果没有会被认为是0）


#### **操作员**

操作员是可以代表持有者发送和销毁代币的账号地址。

当地址成为持有者的操作员时，需要触发 `AuthorizedOperator` 事件。触发事件时操作员是第
一个参数，持有者是第二个参数。

撤销时需要触发 `RevokedOperator` 事件。触发事件时操作员是第一个参数，持有者是第二个参数。

*注意*: 持有者可以有多个操作员。

合约可以定义默认操作员，所有的持有者都隐含授权给默认操作员。

定义默认的操作员不能触发 `AuthorizedOperator` 事件，默认操作员需遵守以下规则：


- 代币合约必须在创建时设置默认操作员。

- 默认操作员是不可变的，任何时候不可以添加和删除。

- 设置默认操作员不能触发 `AuthorizedOperator` 事件。

- 持有者必须允许撤销默认操作员，除非默认操作员本身就是持有者。

- 持有者必须允许重新授权之前的默认操作员。

- 当默认操作员被显示的授权或撤销，需要相应的触发 `AuthorizedOperator` 或 `RevokedOperator` 事件

以下是任何操作员需遵守的规则：


- 每个地址都是其自身的操作员，因此不能被撤销。

- 如果地址是某个持有者的操作员, `isOperatorFor` 返回 `true` ，否则返回 `false` .

- 触发`AuthorizedOperator` 事件，要确保参数正确。参考[`AuthorizedOperator` 事件](#authorizedoperator)

- 触发 `RevokedOperator` 事件，要确保参数正确。参考[`RevokedOperator` 事件](#revokedoperator)

*注意*: 持有者也许会重复授权一个操作员，每次都需要触发`AuthorizedOperator`事件。

*注意*: A 持有者也许会撤销一个操作员，每次都需要触发`RevokedOperator`事件。

**`AuthorizedOperator` 事件** <a id="authorizedoperator"></a>

``` solidity
event AuthorizedOperator(address indexed operator, address indexed holder)
```

指示持有者授权一个操作员。

*注意*: 不能在授权过程之外触发。

* 参数：
  * `operator`: 操作员地址
  * `holder`: 持有者地址

**`RevokedOperator` 事件** <a id="revokedoperator"></a>

``` solidity
event RevokedOperator(address indexed operator, address indexed holder)
```

指示持有者撤销操作员。

*注意*: 不能在撤销过程之外触发事件。

* 参数：
`operator`: 操作员地址
`holder`: 持有者地址

下面描述的 `defaultOperators`, `authorizeOperator`, `revokeOperator` 及 `isOperatorFor` 函数用来实现对操作员的管理。

当然代币合约也可以实现其他的函数去管理操作员.

**`defaultOperators` 函数** <a id="defaultOperators"></a>

``` solidity
function defaultOperators() external view returns (address[] memory)
```

获取代币合约默认的操作员列表。


*注意*: 如果代币合约没有默认操作员, 必须返回空列表。

* 接口ID: `06e48538`
* 返回值: 所有的默认操作员列表。

**`authorizeOperator` 函数**

``` solidity
function authorizeOperator(address operator) external
```

设置一个第三方的 `operator` 地址作为`msg.sender` 的操作员，此操作员可以代表 `msg.sender` 发送和销毁代币。

*注意*: 持有者 (`msg.sender`) 总是自身的操作员。
因此，当出现授权自己作为操作员时（`operator` 等于 `msg.sender`）函数需要 `revert`。


* 接口ID: `959b8c3f`
* 参数：
  * `operator`: `msg.sender` 的操作员地址

**`revokeOperator` 函数**

``` solidity
function revokeOperator(address operator) external
```

移除 `msg.sender` 的 操作员权限。


*注意*: T持有者 (`msg.sender`) 总是自身的操作员。因此，当出现移除自己时（即`operator` 等于 `msg.sender`）函数需要 `revert`。

* 接口ID: `fad8b32a`
* 参数：
   * `operator`: 要取消的`msg.sender` 的操作员地址

**`isOperatorFor` 函数** <a id="isOperatorFor"></a>

``` solidity
function isOperatorFor(
    address operator,
    address holder
) external view returns (bool)
```

是否是某个持有者的操作员。

* 接口ID: `d95b6371`
* 参数：
  * `operator`: 操作员
  * `holder`: 持有者
* 返回值: 是某个持有者的操作员 返回 `true` 否则 `false`。

*注意*: 要知道持有者有哪些操作员，需要字每个 默认操作员上调用`isOperatorFor`，同时解析 `AuthorizedOperator` 和 `RevokedOperator` 事件，进行相应的查询。

#### **发送代币**

当操作员从持有者账号发送 `amount` 数量的token给接收者时，代币合约必须遵守以下规则：

- 任何授权的操作员可以发送代币到任何的接收者地址(除了 `0x0`)。

- 持有者余额减掉 `amount` 数量。

- 接收者余额加上 `amount` 数量。

- 持有者余额必须大于等于 `amount`，发送之后结果大于0。

- 代币合约必须触发`Sent`事件，参考 [`Sent`事件](#sent)。

- 操作员也许会使用 `operatorData` 参数携带信息。

- 如果持有者有通过 [ERC1820] 注册  `ERC777TokensSender`  实现接口， 代币合约必须调用其 `tokensToSend` 钩子函数。

- 如果接收者有通过 [ERC1820] 注册  `ERC777TokensRecipient`  实现接口， 代币合约必须调用其 `tokensReceived` 钩子函数。

- 在整个发送过程 `data` 和 `operatorData` 必须保持不可变 &mdash; 因此同样的数据要用于调用调用钩子函数和触发`Sent`事件。


发送代币时，在以下的情况下，合约需要 `revert` ：

- 未经授权的操作员。

- 发送之后 持有者或接收者的余额不是 粒度 *granularity* 的整数倍。

- 接收者是合约地址，而又没有按 [ERC1820]实现`ERC777TokensRecipient` 接口。

- 持有者或接收者有一个为 `0x0`

- 出现结果合约为 负数。

- 持有者在 `tokensToSend` 函数中进行了 `revert`。

- 接收者在 `tokensReceived` 函数中进行了 `revert`。



代币合约可以从多个持有者发送到多个接收者，在这种情况下：

- 上面的发送规则对所有的持有者和接收者都要遵守。
- 余额增加的总和要等于发送的`amount`。
- 余额减去的总和要等于发送的`amount`。
- 每一组持有者和接收者（使用相应的金额），都要触发 `Sent` 。
- `Sent` 事件的金额之和要等于发送的 `amount`.

*注意*: 诸如对发送收取费用的机制被视为发送给多个接收者：一个是转移目标接收者， 一个是费用接受者。

*注意*: 代币的转移也许是链式的，例如：可以在收到代币或转移到其他地址，转移时同样要遵照以上规则。

*注意*: 发送零个数量也是有效的交易，需要正确处理。

*实现要求*:
- 代币合约需要在修改状态之前调用`tokensToSend` 钩子函数。
- 代币合约需要在修改状态之后调用`tokensReceived` 钩子函数。
如： `tokensToSend` 要首先调用，然后更新余额状态，再调用 `tokensReceived`， 因此如果在`tokensToSend`中获取`balanceOf`的话是发送之前的结果，同理在  `tokensReceived` 这是发送之后的值。

*注意*: `data` 字段的信息由持有者提供 &mdash; 类似于发送以太时的 data 字段。`tokensToSend()` 和 `tokensReceived()` 可以使用这个信息来确定是否拒绝交易。

*注意*: `operatorData` 字段类似，只不过信息必须由操作员提供。这个信息可以用于日志或特定的场景，如：支付票号，附属签名等。大多数情况下，接受者可以忽略`operatorData` （仅做日志记录）。


**`Sent` 事件** <a id="sent"></a>

``` solidity
event Sent(
    address indexed operator,
    address indexed from,
    address indexed to,
    uint256 amount,
    bytes data,
    bytes operatorData
)
```

指示发送代币事件。

*注意*: 不能在发送函数 send（或 [ERC20] transfer 函数 ） 之外触发。

* 参数：
  * `operator`:  触发发送的地址
  * `from`: 持有者
  * `to`: 接收者
  * `amount`: 发送的代币数量
  * `data`: 持有者提供的信息
  * `operatorData`: 操作员提供的信息

下面的 `send` 和 `operatorSend` 必须用于实现发送代币，当然合约也可以实现其他的方法来发送。


**`send` 函数**

``` solidity
function send(address to, uint256 amount, bytes calldata data) external
```

给地址`to`发送 amount 数量的代币。

操作员和持有者必须都是`msg.sender`.

* 接口ID: `9bd9bbc6`
* 参数：
 * `to`: 代币接收者.
 * `amount`: 发送的代币数量
 * `data`: 持有者提供的信息

**`operatorSend` 函数**

``` solidity
function operatorSend(
    address from,
    address to,
    uint256 amount,
    bytes calldata data,
    bytes calldata operatorData
) external
```

操作员（msg.sender）代表 `from`地址 给地址`to`发送 amount 数量的代币。


*记住*: 如果操作员没得到 `from`地址的授权，必须`revert`

*注意*: `from` 和 `msg.sender` 可以是相同的地址。
例如: 地址可以自己调用 `operatorSend`，相当于调用`send`时用了确定的操作员数据（而这不可以通过`send`实现）

* 接口ID: `62ad1b83`
* 参数：
  * `from`: 代币持有者
  * `to`: 代币接收者
  * `amount`: 发送的代币数量
  * `data`: 持有者提供的信息
  * `operatorData`: 操作员提供的信息

#### **铸造代币（Minting）**

铸造代币是产生新币的过程。


[ERC777]故意没有定义铸币函数。用意是不希望限制[ERC777]标准的使用，因为铸币通常特定于特定的代币。

尽管如此，在为接收者铸币必须遵守以下规则：

- 接收者是不为 0 的任何地址。

- 发行量需要加上铸币量

- `0x0` 地址的余额不可以减少

- 接收者的余额加上铸币量

- 代币合约必须触发 `Minted` 事件，注意参数正确。参考 [`Minted` 事件](#minted)。

- 如果接收者有通过 ERC1820 注册 ERC777TokensRecipient 实现接口， 代币合约必须调用其 tokensReceived 钩子函数。

- 在整个发送过程 data 和 operatorData 必须保持不可变 — 因此同样的数据要用于调用调用钩子函数 `tokensReceived` 和触发`Minted`事件。

铸币时，如果发生以下情况，代币合约必须 `revert`：

- 铸币后持有者或接收者的余额不是 粒度 granularity 的整数倍。
- 接收者是合约地址，而又没有按 [ERC1820] 实现ERC777TokensRecipient 接口。
- 接收者为 0x0 地址。
- 接收者在 tokensReceived 函数中进行了 `revert` 。

*注意*: 代币合约部署时的初始代币供应必须被视为铸币过程，需要符合以上规则：必须发出一个或多个`Minted` 事件，必须调用收件人的`tokensReceived`钩子函数。

*[ERC20] 兼容性需要*:

如果合约要需要兼容 [ERC20]，铸币时 `Sent` 事件不能触发，应该触发 [ERC20] 定义的 `Transfer`事件 （`from` 用 `0x0`）。


代币合约可以一次为多个接收者铸币，在这种情况下：

- 上面的规则对所有接收者都要遵守。
- 余额增加的总和要等于铸币数量。
- `Minted`事件必须为每个接收者触发（用相应的数量）。
- `Minted`事件的金额之和要等于铸币数量`amount`.

*注意*: 铸币零个数量也是有效的交易，需要正确处理。

*注意*: 在发送和销毁时，data 字段由持有者提供，这个不适用铸币，这个数据可以由合约或操作员提供。

*注意*: `operatorData` 字段由操作员提供 &mdash; 类似于发送以太币交易的 data 字段，tokensReceived() 可以使用这个信息来确定是否拒绝铸币交易。


**`Minted` 事件** <a id="minted"></a>

``` solidity
event Minted(
    address indexed operator,
    address indexed to,
    uint256 amount,
    bytes data,
    bytes operatorData
)
```

指示铸币事件。

*注意*: 铸币事件不能在铸币过程之外触发

* 参数：
  * `operator`: 触发铸币的地址
  * `to`: 铸币接收者
  * `amount`: 铸币量
  * `data`: 提供给接收者的信息.
  * `operatorData`: 操作员提供的信息.

#### **销毁代币**

销毁代币或称销毁代币

[ERC777] 明确的定义了两个函数用于销毁代币 (`burn` 和 `operatorBurn`)，方便钱包和dapps有统一的接口交互。

但是，代币合约可以出于任何原因阻止部分或全部持有者销毁代币。代币合约也可以定义销毁代币的其他函数。

在销毁持有者的代币时，必须遵守以下规则：

- 代币持有者不可以是 `0x0` 地址。
- 总供应量必须减少代币销毁量。
- “0x0”的余额不得增加。
- 持有者的余额必须减少代币销毁的数量。
- 代币合约必须触发`Burned`，参考 [`Burned` 事件](#burned)。
- 代币合约必须调用持有者的`tokensToSend`钩子函数， 如果持有者通过[ERC1820]注册`ERC777TokensSender` 实现。
- 在销毁过程中 `operatorData` 必须保持不可变 &mdash; 因为同样的 `operatorData` 用于 调用 `tokensToSend` 和触发 `Burned` 事件。

销毁时，如果发生以下情况，代币合约必须 revert：

- 操作员没有授权。
- 销毁代币后，持有者余额不是 粒度（granularity） 的整数倍。
- 持有者的余额不及代币的销毁量（销毁后，为负）。
- 持有者是 `0x0` 地址。
- 持有者 `tokensToSend` 进行了 `revert`。

*[ERC20] 兼容性需要*:

如果合约要需要兼容 [ERC20]，销毁时 `Sent` 事件不能触发，应该触发 [ERC20] 定义的 `Transfer`事件 （`to` 用 `0x0`）。
[ERC20] 没有定义销毁，不过这个是普遍接受的实践。


代币合约可以一次为多个持有者销毁代币。 在这种情况下：

- 每个持有者都需要满足以上规则。
- 所有余额减少的总和必须等于总销毁量。
- 每个持有者必须触发`Burned`事件（用相应的数量）
- `Burned`事件中所有金额的总和必须等于“销毁总量”。

*注意*: 销毁零个数量也是有效的交易，需要正确处理。

*注意*: `data` 字段字段由持有者提供 &mdash; 类似于发送以太币交易的 data 字段，两个钩子函数  `tokensToSend()` `tokensReceived()` 可以使用这个信息来确定是否拒绝销毁交易。

*注意*: `operatorData` 字段类似，不过它由操作员提供

**`Burned` 事件** <a id="burned"></a>

``` solidity
event Burned(
    ddress indexed operator,
    address indexed from,
    uint256 amount,
    bytes data,
    bytes operatorData
);
```

指示销毁事件。

*注意*: 不能在销毁过程之外触发。

* 参数：
  * `operator`: 触发销毁的地址
  * `from`: 从哪个账号销毁
  * `amount`: 销毁数量
  * `data`: 持有者提供的信息
  * `operatorData`: 操作员提供的信息

以下描述的函数 `burn` 和 `operatorBurn` 必须用来实现代币销毁，当然也可以实现自己的函数。

**`burn` 函数**

``` solidity
function burn(uint256 amount, bytes calldata data) external
```

从 `msg.sender` 账号销毁  `amount` 数量的代币。

操作员和持有者必须都是`msg.sender`。

* 接口ID: `fe9d9303`
* 参数：
  * `amount`: 销毁数量
  * `data`: 持有者提供的信息

**`operatorBurn` 函数**

``` solidity
function operatorBurn(
    address from,
    uint256 amount,
    bytes calldata data,
    bytes calldata operatorData
) external
```

`msg.sender` 操作员从 `from` 账号销毁  `amount` 数量的代币。


*记住*: 如果操作员没有授权，需要 `revert` 。

* 接口ID: `fc673c4f`
* 参数：
  * `from`: 销毁代币的账号（持有者）
  * `amount`: 销毁数量
  * `data`: 持有者提供的信息
  * `operatorData`: 操作员提供的信息

*注意*: 操作员可以用 `operatorData` 传递任何信息，信息必须是操作员提供的。

*注意*: `from` 和 `msg.sender` 可以是相同的地址。

例如: 持有者可以自己调用 `operatorBurn` ，相当于用了额外的操作员及信息`operatorData` 调用 `burn`。（而 `burn` 函数自身无法实现 ）

#### **钩子函数：`ERC777TokensSender`和`tokensToSend` **

The `tokensToSend` hook notifies of any request to decrement the balance (send 和 burn) for a given 持有者.
Any address (regular or 合约) wishing to be notified of 代币 debits from their address
MAY register the address of a 合约 implementing the `ERC777TokensSender` interface described below via [ERC1820].

> This is done by calling the `setInterfaceImplementer` function on the [ERC1820] registry
> with the 持有者 address as the address,
> the `keccak256` hash of `ERC777TokensSender`
> (`0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895`) as the interface hash,
>和address of the 合约 implementing the `ERC777TokensSender` as the implementer.

``` solidity
interface ERC777TokensSender {
    function tokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}
```

*注意*: A regular address MAY register a different address&mdash;the address of a 合约&mdash;implementing
the interface on its behalf.
A 合约 MAY register either its address or the address of another 合约
but said address MUST implement the interface on its behalf.

**`tokensToSend`**

``` solidity
function tokensToSend(
    address operator,
    address from,
    address to,
    uint256 amount,
    bytes calldata userData,
    bytes calldata operatorData
) external
```

Notify a request to send or burn (if `to` is `0x0`) an `amount` 代币 from the `from` address to the `to` address
by the `operator` address.

*注意*: This function MUST NOT be called outside of a burn, send or [ERC20] transfer process.

* 接口ID: `75ab9782`
* 参数：
  * `operator`: Address which triggered the balance decrease (through sending or burning).
  * `from`: 持有者 whose 代币 were sent.
  * `to`: Recipient of the 代币 for a send (or `0x0` for a burn).
  * `amount`: Number of 代币 the 持有者 balance is decreased by.
  * `data`: Information provided by the 持有者.
  * `operatorData`: Information provided by 操作员.

The following rules apply when calling the `tokensToSend` hook:

- The `tokensToSend` hook MUST be called for every send 和 burn processes.

- The `tokensToSend` hook MUST be called *before* the state is updated&mdash;i.e. *before* the balance is decremented.

- `operator` MUST be the address which triggered the send or burn process.

- `from` MUST be the address of the 持有者 whose 代币 are sent or burned.

- `to` MUST be the address of the 接收者 which receives the 代币 for a send.

- `to` MUST be `0x0` for a burn.

- `amount` MUST be the number of 代币 the 持有者 sent or burned.

- `data` MUST contain the extra information (if any) provided to the send or the burn process.

- `operatorData` MUST contain the extra information provided by the address
  which triggered the decrease of the balance (if any).

- The 持有者 MAY block a send or burn process by `revert`ing.
  (例如: reject the withdrawal of 代币 from its account.)

*注意*: Multiple 持有者 MAY use the same implementation of `ERC777TokensSender`.

*注意*: An address can register at most one implementation at any given time for all [ERC777] 代币.
Hence the `ERC777TokensSender` MUST expect to be called by different 代币 contracts.
The `msg.sender` of the `tokensToSend` call is expected to be the address of 代币合约.

*[ERC20] compatibility requirement*:
This hook takes precedence over [ERC20] 和 MUST be called (if registered)
when calling [ERC20]'s `transfer` 和 `transferFrom` event.
When called from a `transfer`, `operator` MUST be the same value as the `from`.
When called from a `transferFrom`, `operator` MUST be the address which issued the `transferFrom` call.

#### **`ERC777TokensRecipient`和`tokensReceived` Hook**

The `tokensReceived` hook notifies of any increment of the balance (send 和 mint) for a given 接收者.
Any address (regular or 合约) wishing to be notified of 代币 credits to their address
MAY register the address of a 合约 implementing the `ERC777TokensSender` interface described below via [ERC1820].

> This is done by calling the `setInterfaceImplementer` function on the [ERC1820] registry
> with the 接收者 address as the address,
> the `keccak256` hash of `ERC777TokensRecipient`
> (`0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b`) as the interface hash,
>和address of the 合约 implementing the `ERC777TokensRecipient` as the implementer.

``` solidity
interface ERC777TokensRecipient {
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;
}
```

If the 接收者 is a 合约, which has not registered an `ERC777TokensRecipient` implementation;
then 代币合约:

- MUST `revert` if the `tokensReceived` hook is called from a mint or send call.

- SHOULD continue processing the transaction
  if the `tokensReceived` hook is called from an ERC20 `transfer` or `transferFrom` call.

*注意*: A regular address MAY register a different address&mdash;the address of a 合约&mdash;implementing
the interface on its behalf.
A 合约 MUST register either its address or the address of another 合约
but said address MUST implement the interface on its behalf.

**`tokensReceived`**

``` solidity
function tokensReceived(
    address operator,
    address from,
    address to,
    uint256 amount,
    bytes calldata data,
    bytes calldata operatorData
) external
```

Notify a send or mint (if `from` is `0x0`) of `amount` 代币 from the `from` address to the `to` address
by the `operator` address.

*注意*: This function MUST NOT be called outside of a mint, send or [ERC20] transfer process.

* 接口ID: `0023de29`
* 参数：
  `operator`: Address which triggered the balance increase (through sending or minting).
  `from`: 持有者 whose 代币 were sent (or `0x0` for a mint).
  `to`: Recipient of the 代币.
  `amount`: Number of 代币 the 接收者 balance is increased by.
  `data`: Information provided by the 持有者.
  `operatorData`: Information provided by 操作员.

The following rules apply when calling the `tokensReceived` hook:

- The `tokensReceived` hook MUST be called for every send 和 mint processes.

- The `tokensReceived` hook MUST be called *after* the state is updated&mdash;i.e. *after* the balance is incremented.

- `operator` MUST be the address which triggered the send or mint process.

- `from` MUST be the address of the 持有者 whose 代币 are sent for a send.

- `from` MUST be `0x0` for a mint.

- `to` MUST be the address of the 接收者 which receives the 代币.

- `amount` MUST be the number of 代币 the 接收者 sent or minted.

- `data` MUST contain the extra information (if any) provided to the send or the mint process.

- `operatorData` MUST contain the extra information provided by the address
  which triggered the increase of the balance (if any).

- The 持有者 MAY block a send or mint process by `revert`ing.
  (例如: reject the reception of 代币.)

*注意*: Multiple 持有者 MAY use the same implementation of `ERC777TokensRecipient`.

*注意*: An address can register at most one implementation at any given time for all [ERC777] 代币.
Hence the `ERC777TokensRecipient` MUST expect to be called by different 代币 contracts.
The `msg.sender` of the `tokensReceived` call is expected to be the address of 代币合约.

*[ERC20] compatibility requirement*:
This hook takes precedence over [ERC20] 和 MUST be called (if registered)
when calling [ERC20]'s `transfer` 和 `transferFrom` event.
When called from a `transfer`, `operator` MUST be the same value as the `from`.
When called from a `transferFrom`, `operator` MUST be the address which issued the `transferFrom` call.

#### **Note On Gas Consumption**

Dapps 和 wallets SHOULD first estimate the gas required when sending, minting, or 销毁代币&mdash;using
[`eth_estimateGas`][eth_estimateGas]&mdash;to avoid running out of gas during the transaction.

### Logo

| **Image** | ![beige logo] | ![white logo] | ![light grey logo] | ![dark grey logo] | ![black logo] |
|----------:|:-------------:|:-------------:|:------------------:|:-----------------:|:-------------:|
| **Color** | beige         | white         | light grey         | dark grey         | black         |
| **Hex**   | `#C99D66`     | `#FFFFFF`     | `#EBEFF0`          | `#3C3C3D`         | `#000000`     |

The logo MAY be used, modified 和 adapted to promote valid [ERC777] 代币 implementations
and [ERC777] compliant technologies such as wallets 和 dapps.

[ERC777] 代币合约 authors MAY create a specific logo for their 代币 based on this logo.

The logo MUST NOT be used to advertise, promote or associate in any way technology&mdash;such
as 代币&mdash;which is not [ERC777] compliant.

The logo for the standard can be found in the [`/assets/eip-777/logo`][logos] folder in `SVG` 和 `PNG` formats.
The `PNG` version of the logo offers a few sizes in pixels.
If needed, other sizes MAY be created by converting from `SVG` into `PNG`.

## 原理阐述

The principal intent for this standard is
to solve some of the shortcomings of [ERC20] while maintaining backward compatibility with [ERC20],
and avoiding the problems 和 vulnerabilities of [EIP223].

Below are the rationales for the decisions regarding the main aspects of the standards.

*注意*: Jacques Dafflon ([0xjac]), one of the authors of the standard,
conjointly wrote his [master thesis] on the standard,
which goes in more details than could reasonably fit directly within the standard,
and can provide further clarifications regarding certain aspects or decisions.

### Lifecycle

More than just sending 代币, [ERC777] defines the entire lifecycle of a 代币,
starting with the minting process, followed by the sending process 和 terminating with the burn process.

Having a lifecycle clearly defined is important for consistency 和 accuracy,
especially when value is derived from scarcity.
In contrast when looking at some [ERC20] 代币, a discrepancy can be observed
between the value returned by the `totalSupply`和actual circulating supply,
as the standard does not clearly define a process to create 和 destroy 代币.

### Data

The mint, send 和 burn processes can all make use of a `data` 和 `operatorData` fields
which are passed to any movement (mint, send or burn).
Those fields may be empty for simple use cases,
or they may contain valuable information related to the movement of 代币,
similar to information attached to a bank transfer by the sender or the bank itself.

The use of a `data` field is equally present in other standard proposals such as [EIP223],
and was requested by multiple members of the community who reviewed this standard.

### Hooks

In most cases, [ERC20] requires two calls to safely transfer 代币 to a 合约 without locking them.
A call from the sender, using the `approve` function
and a call from the recipient using `transferFrom`.
Furthermore, this requires extra communication between the parties which is not clearly defined.
Finally, holders can get confused between `transfer` 和 `approve`/`transferFrom`.
Using the former to transfer 代币 to a 合约 will most likely result in locked 代币.

Hooks allow streamlining of the sending process 和 offer a single way to send 代币 to any recipient.
Thanks to the `tokensReceived` hook, contracts are able to react 和 prevent locking 代币 upon reception.

#### **Greater Control For Holders**

The `tokensReceived` hook also allows holders to reject the reception of some 代币.
This gives greater control to holders who can accept or reject incoming 代币 based on some parameters,
for example located in the `data` or `operatorData` fields.

Following the same intentions 和 based on suggestions from the community,
the `tokensToSend` hook was added to give control over 和 prevent the movement of outgoing 代币.

#### **[ERC1820] 注册表合约**

The [ERC1820] 注册表合约 allows holders to register their hooks.
Other alternatives were examined beforehand to link hooks 和 holders.

The first was for hooks to be defined at the sender's or recipient's address.
This approach is similar to [EIP223] which proposes a `tokenFallback` function on recipient contracts
to be called when receiving 代币,
but improves on it by relying on [ERC165] for interface detection.
While straightforward to implement, this approach imposes several limitations.
In particular, the sender 和 recipient must be contracts in order to provide their implementation of the hooks.
Preventing externally owned addresses to benefit from hooks.
Existing contracts have a strong probability not to be compatible,
as they undoubtedly were unaware 和 do not define the new hooks.
Consequently existing smart 合约 infrastructure such as multisig wallets
which potentially hold large amounts of ether 和 代币 would need to be migrated to new updated contracts.

The second approach considered was to use [ERC672] which offered pseudo-introspection for addresses using reverse-ENS.
However, this approach relied heavily on ENS, on top of which reverse lookup would need to be implemented.
Analysis of this approach promptly revealed a certain degree of complexity 和 security concerns
which would transcend the benefits of approach.

The third solution&mdash;used in this standard&mdash;is to rely on a unique 注册表合约
where any address can register the addresses of contracts implementing the hooks on its behalf.
This approach has the advantage that externally owned accounts 和 contracts can benefit from hooks,
including existing contracts which can rely on hooks deployed on proxy contracts.

The decision was made to keep this registry in a separate EIP,
as to not over complicate this standard.
More importantly, the registry is designed in a flexible fashion,
such that other EIPs 和 smart 合约 infrastructures can benefit from it
for their own use cases, outside the realm of [ERC777] 和 代币.
The first proposal for this registry was [ERC820].
Unfortunately, issues emanating from upgrades in the Solidity language to versions 0.5 和 above
resulted in a bug in a separated part of the registry, which required changes.
This was discovered right after the last call period.
Attempts made to avoid creating a separate EIP, such as [ERC820a], were rejected.
Hence the standard for the registry used for [ERC777] became [ERC1820].
[ERC1820] 和 [ERC820] are functionally equivalent. [ERC1820] simply contains the fix for newer versions of Solidity.

### Operators

The standard defines the concept of operators as any address which moves 代币.
While intuitively every address moves its own 代币,
separating the concepts of holder 和 operator allows for greater flexibility.
Primarily, this originates from the fact that the standard defines a mechanism for holders
to let other addresses become their operators.
Moreover, unlike the approve calls in [ERC20] where the role of an approved address is not clearly defined,
[ERC777] details the intent of 和 interactions with operators,
including an obligation for operators to be approved,
and an irrevocable right for any holder to revoke operators.

#### *默认操作员*

Default operators were added based on community demand for pre-approved operators.
That is operators which are approved for all holders by default.
For obvious security reasons, the list of default operators is defined at 代币合约 creation time,
and cannot be changed.
Any holder still has the right to revoke default operators.
One of the obvious advantages of default operators is to allow ether-less movements of 代币.
Default operators offer other usability advantages,
such as allowing 代币 providers to offer functionality in a modular way,
and to reduce the complexity for holders to use features provided through operators.

## Backward Compatibility

This EIP does not introduce backward incompatibilities 和 is backward compatible with the older [ERC20] 代币 standard.

This EIP does not use `transfer` 和 `transferFrom` 和 uses `send` 和 `operatorSend`
to avoid confusion 和 mistakes when deciphering which 代币 standard is being used.

This standard allows the implementation of [ERC20] functions `transfer`, `transferFrom`, `approve` 和 `allowance`
alongside to make a 代币 fully compatible with [ERC20].

The 代币 MAY implement `decimals()` for backward compatibility with [ERC20].
If implemented, it MUST always return `18`.

Therefore a 代币合约 MAY implement both [ERC20] 和 [ERC777] in parallel.
The specification of the `view` functions (such as `name`, `symbol`, `balanceOf`, `totalSupply`) 和 internal data
(such as the mapping of balances) overlap without problems.
Note however that the following functions are mandatory in [ERC777] 和 MUST be implemented:
`name`, `symbol` `balanceOf` 和 `totalSupply`
(`decimals` is not part of the [ERC777] standard).

The state-modifying functions from both standards are decoupled 和 can operate independently from each other.
Note that [ERC20] functions SHOULD be limited to only being called from old contracts.

If the 代币 implements [ERC20],
it MUST register the `ERC20Token` interface with its own address via [ERC1820].
This is done by calling the `setInterfaceImplementer` function on the ERC1820 registry
with 代币合约 address as both the address和implementer
and the `keccak256` hash of `ERC20Token` (`0xaea199e31a596269b42cdafd93407f14436db6e4cad65417994c2eb37381e05a`)
as the interface hash.

If the 合约 has a switch to enable or disable ERC20 functions, every time the switch is triggered,
the 代币 MUST register or unregister the `ERC20Token` interface for its own address accordingly via ERC1820.
Unregistering implies calling the `setInterfaceImplementer` with 代币合约 address as the address,
the `keccak256` hash of `ERC20Token` as the interface hash 和 `0x0` as the implementer.
(See [Set An Interface For An Address][erc1820-set] in [ERC1820] for more details.)

The difference for new contracts implementing [ERC20] is that
`tokensToSend` 和 `tokensReceived` hooks take precedence over [ERC20].
Even with an [ERC20] `transfer` 和 `transferFrom` call, 代币合约 MUST check via [ERC1820]
if the `from`和`to` address implement `tokensToSend` 和 `tokensReceived` hook respectively.
If any hook is implemented, it MUST be called.
Note that when calling [ERC20] `transfer` on a 合约, if the 合约 does not implement `tokensReceived`,
the `transfer` call SHOULD still be accepted even if this means the 代币 will probably be locked.

The table below summarizes the different actions 代币合约 MUST take
when sending, minting 和 transferring 代币 via [ERC777] 和 [ERC20]:

<table>
  <tr>
    <th align="right">ERC1820</th>
    <th><code>to</code> address</th>
    <th align="center">ERC777 Sending 和 Minting</th>
    <th align="center">ERC20 <code>transfer</code>/<code>transferFrom</code></th>
  </tr>
  <tr>
    <td rowspan="2" align="right">
      <code>ERC777TokensRecipient</code><br/>registered
    </td>
    <td>regular address</td>
    <td colspan="2" rowspan="2" align="center">
      MUST call <code>tokensReceived</code>
    </td>
  </tr>
  <tr>
    <td>合约</td>
  </tr>
  <tr>
    <td rowspan="2" align="right">
      <code>ERC777TokensRecipient</code><br/>not registered
    </td>
    <td>regular address</td>
    <td colspan="2" align="center">continue</td>
  </tr>
  <tr>
    <td>合约</td>
    <td align="center">MUST <code>revert</code></td>
    <td align="center">SHOULD continue<sup><a id="continue-footnote-backlink" href="#continue-footnote">1</a></sup></td>
  </tr>
</table>

> <a href="#continue-footnote-backlink"><small id="continue-footnote">1.</a>
The transaction SHOULD continue for clarity as ERC20 is not aware of hooks.
However, this can result in accidentally locked 代币.
If avoiding accidentally locked 代币 is paramount, the transaction MAY <code>revert</code>.


There is no particular action to take if `tokensToSend` is not implemented.
The movement MUST proceed 和 only be canceled if another condition is not respected
such as lack of funds or a `revert` in `tokensReceived` (if present).

During a send, mint 和 burn, the respective `Sent`, `Minted` 和 `Burned`事件s MUST be emitted.
Furthermore, if 代币合约 declares that it implements `ERC20Token` via [ERC1820],
代币合约 SHOULD emit `Transfer`事件 for minting 和 burning
and必须触发`Transfer`事件 for sending (as specified in the [ERC20] standard).
During an [ERC20]'s `transfer` or `transferFrom` functions, a valid `Sent` 事件MUST be emitted.

Hence for any movement of 代币, two events MAY be emitted:
an [ERC20] `Transfer` 和 an [ERC777] `Sent`, `Minted` or `Burned` (depending on the type of movement).
Third-party developers MUST be careful not to consider both events as separate movements.
As a general rule, if an application considers the 代币 as an ERC20 代币,
then only the `Transfer` event MUST be taken into account.
If the application considers the 代币 as an ERC777 代币,
then only the `Sent`, `Minted` 和 `Burned`事件s MUST be considered.

## 测试用例

The [repository with the reference implementation][0xjac/ERC777] contains all the [tests][ref tests].

## 实现

The GitHub repository [0xjac/ERC777] contains the [reference implementation].
The reference implementation is also available via [npm][npm/erc777] 和 can be installed with `npm install erc777`.

## 版权

原文采用[CC0](https://creativecommons.org/publicdomain/zero/1.0/)， 本翻译采用[BY-NC-ND](https://learnblockchain.cn/about/#%E7%89%88%E6%9D%83%E5%8F%8A%E8%BD%AC%E8%BD%BD%E5%A3%B0%E6%98%8E)许可协议，译者：深入浅出区块链 Tiny熊。

[operators]: #operators

[ERC20]: https://learnblockchain.cn/docs/eips/eip-20.html
[ERC165]: https://learnblockchain.cn/docs/eips/eip-165.html
[ERC672]: https://github.com/ethereum/EIPs/issues/672
[ERC777]: https://learnblockchain.cn/docs/eips/eip-777.html
[ERC820]: https://learnblockchain.cn/docs/eips/eip-820.html
[ERC820a]: https://github.com/ethereum/EIPs/pull/1758
[ERC1820]: https://learnblockchain.cn/docs/eips/eip-1820.html
[erc1820-set]: https://learnblockchain.cn/docs/eips/eip-1820.html#为接口设置实现地址
[0xjac]: https://github.com/0xjac
[0xjac/ERC777]: https://github.com/0xjac/ERC777
[master thesis]: https://github.com/0xjac/master-thesis
[npm/erc777]: https://www.npmjs.com/package/erc777
[ref tests]: https://github.com/0xjac/ERC777/blob/master/test/ReferenceToken.test.js
[reference implementation]: https://github.com/0xjac/ERC777/blob/master/contracts/examples/ReferenceToken.sol
[EIP223]: https://github.com/ethereum/EIPs/issues/223
[eth_estimateGas]: https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_estimategas
[authorizedoperator]: #authorizedoperator
[revokedoperator]: #revokedoperator
[isOperatorFor]: #isOperatorFor
[defaultOperators]: #defaultOperators
[sent]: #sent
[minted]: #minted
[burned]: #burned
[logos]: https://github.com/ethereum/EIPs/tree/master/assets/eip-777/logo
[beige logo]: ../assets/eip-777/logo/png/ERC-777-logo-beige-48px.png
[white logo]: ../assets/eip-777/logo/png/ERC-777-logo-white-48px.png
[light grey logo]: ../assets/eip-777/logo/png/ERC-777-logo-light_grey-48px.png
[dark grey logo]: ../assets/eip-777/logo/png/ERC-777-logo-dark_grey-48px.png
[black logo]: ../assets/eip-777/logo/png/ERC-777-logo-black-48px.png

[CC0]: https://creativecommons.org/publicdomain/zero/1.0/
