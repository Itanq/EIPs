---
eip: 777
title: ERC777 代币标准
author: Jacques Dafflon <mail@0xjac.com>, Jordi Baylina <jordi@baylina.cat>, Thomas Shababi <tom@truelevel.io>
discussions-to: https://github.com/ethereum/EIPs/issues/777
status: Final
type: Standards Track
category: ERC
created: 2017-11-20
requires: 1820
---

## 简要说明

此EIP定义了ERC777 代币合约标准接口。

## 摘要

ERC777 与[ERC20]的向后兼容， 同时也定义了一些更高级的方法和代币进行交互。

如：*操作者（operators）* 可以代表另一个地址（合约或普通账户）发送代币， 以及 send/receive 加入了钩子函数（*hooks* ）让代币持有者可以有更多的控制。

ERC777 同样采用了 [ERC1820] 标准的优点，判断接受代币的地址是合约还是普通地址，并且判断合约是否兼容ERC777协议。

## 动机


标准尝试改进大家常用的 [ERC20] 代币标准。
ERC777标准的主要优点有：

1. 使用和发送以太相同的理念发送token，方法为：`send(dest, value, data)`.

2. 合约和普通地址都可以通过注册`tokensToSend` hook函数来控制和拒绝发送哪些token（拒绝发送通过在hook函数`tokensToSend` 里 `revert` 来实现）。
3. 合约和普通地址都可以通过注册`tokensReceived` hook函数来控制和拒绝接受哪些token（拒绝接受通过在hook函数`tokensReceived` 里 `revert` 来实现）。

4. `tokensReceived` 可以通过hook函数可以做到在一个交易里完成发送代币和通知合约接受代币，而不像 [ERC20] 必须通过两次调用（`approve`/`transferFrom`）来完成。

5. 持有者可以"授权"和"撤销"操作员（operators: 可以代表持有者发送代币）。
   这些操作员通常是（去中心化）交易所、支票处理机或自动支付系统。

1. 每个代币交易都包含 `data` 和 `operatorData` 字段， 可以分别传递来自持有者和操作员的数据。

2. 可以通过部署实现 `tokensReceived` 的代理合约来兼容没有实现`tokensReceived` 函数的地址。

## 规范

### ERC777Token (代币合约)

``` solidity
interface ERC777Token {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function totalSupply() external view returns (uint256);
    function balanceOf(address holder) external view returns (uint256);
    function granularity() external view returns (uint256);

    function defaultOperators() external view returns (address[] memory);
    function isOperatorFor(
        address operator,
        address holder
    ) external view returns (bool);
    function authorizeOperator(address operator) external;
    function revokeOperator(address operator) external;

    function send(address to, uint256 amount, bytes calldata data) external;
    function operatorSend(
        address from,
        address to,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    function burn(uint256 amount, bytes calldata data) external;
    function operatorBurn(
        address from,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;

    event Sent(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );
    event Minted(
        address indexed operator,
        address indexed to,
        uint256 amount,
        bytes data,
        bytes operatorData
    );
    event Burned(
        address indexed operator,
        address indexed from,
        uint256 amount,
        bytes data,
        bytes operatorData
    );
    event AuthorizedOperator(
        address indexed operator,
        address indexed holder
    );
    event RevokedOperator(address indexed operator, address indexed holder);
}
```

ERC777 合约必须实现上述接口，也必须遵守以下规范。
合约需要用自己的地址通过 [ERC1820] 标准注册 `ERC777Token` 接口。

> 注册方法是调用[ERC1820] 注册合约的 `setInterfaceImplementer` 方法，参数 _addr 及  _implementer 均是合约的地址，_interfaceHash 是 `ERC777Token` 的  `keccak256` 哈希值， 即`0xac7fbab5f54a3ca8194167523c6753bfeb96a445279294b6125b68cce2177054`


如果合约有一个开关来启用或禁用ERC777功能，每次触发开关时，代币合约必须相应地通过ERC1820注册或取消注册`ERC777Token`接口。

取消注册使用代币合约地址作为参数 `_addr` 、`ERC777Token`的`keccak256`哈希作为接口哈希及'0x0`作为实现者参数 `_implementer` 调用函数`setInterfaceImplementer`，
有关详细信息，请参阅[ERC1820]中的[为接口设置实现地址](https://learnblockchain.cn/docs/eips/eip-1820.html#为接口设置实现地址)

当和代币合约进行交互时，所有的数量和余额都是无符号整型 `uint256` 类型 。总是以18次方存储（ `decimals` 只能是 18），0.5个代币存储为 `500,000,000,000,000,000` (0.5&times;10<sup>18</sup>)
[ERC20]内部处理也是一样（不过decimals可为其他值），最小单位相当于 wei, 用户看见的币相当于 ether。


#### **视图函数**

以下视图函数必须实现：

##### **`name` 函数**

``` solidity
function name() external view returns (string memory)
```

返回代币名称，如： `"MyToken"`

* 接口ID： `06fdde03`
* 返回值：代币名称


##### **`symbol` 函数**

``` solidity
function symbol() external view returns (string memory)
```
返回代币的代号，如`"MYT"`

* 接口ID：`95d89b41`
* 返回值：代币的代号


##### **`totalSupply` 函数**

``` solidity
function totalSupply() external view returns (uint256)
```

返回代币总流通量。


*注意*: 总供应量必须是所有账号余额（`balanceOf`）之和。
*注意*: 总供应量必须等于所有挖出的币（ `Minted` 事件定义）减去燃烧的币（`Burned`事件定义）

* 接口ID：`18160ddd`
* 返回值：代币总流通量


##### **`balanceOf` 函数**

``` solidity
function balanceOf(address holder) external view returns (uint256)
```

返回帐户（通过参数"holder"）的余额，余额 >=0 。


* 接口ID：`70a08231`
* 参数holder： 查询的账号
* 返回值： 在代币合约里对应账号余额


##### **`granularity` 函数**

``` solidity
function granularity() external view returns (uint256)
```

获得代币最小的划分粒度（基于内部单位的个数），最小的挖矿、发送及销毁粒度。

*granularity* 需要满足一下规则：

- *granularity* 必须在创建时设置

- *granularity* 任何时候不可以更改。

- *granularity* 必须大于等于1。

- 所有的余额必须是granularity的整数倍。

- 挖矿、发送及销毁数量必须是granularity的整数倍。

- 非*granularity*的整数倍的操作都需要 `revert` 。

*注意*: 大部分的代币应该是完全可切分的，如果没有特别的理由，这个函数应该返回1。

* 接口ID：`556f0dc7`
* 返回值： 最小的划分粒度


*注意*: `defaultOperators` 和 `isOperatorFor` 也是视图函数，他们在操作员部分定义。


**[ERC20] 兼容性需要**:

代币的 decimals 必须是 `18`。
对于一个 纯粹的 ERC777 代币 [ERC20] 的 `decimals` 函数是可选的，与合约交互的时候不应该依赖这个值（18是隐含值）。

为了兼容 [ERC20] 代币, `decimals` 函数要求必须返回18。 （因为在 [ERC20] 中`decimals` 是可选的，也没有明确的默认值，如果没有会被认为是0）


#### **操作员**

操作员是可以代表持有者发送和销毁代币的账号地址。

当地址成为持有者的操作员时，需要触发 `AuthorizedOperator` 事件。触发事件时操作员是第
一个参数，持有者是第二个参数。

撤销时需要触发 `RevokedOperator` 事件。触发事件时操作员是第一个参数，持有者是第二个参数。

*注意*: 持有者可以有多个操作员。

合约可以定义默认操作员，所有的持有者都隐含授权给默认操作员。

定义默认的操作员不能触发 `AuthorizedOperator` 事件，默认操作员需遵守以下规则：


- 代币合约必须在创建时设置默认操作员。

- 默认操作员是不可变的，任何时候不可以添加和删除。

- 设置默认操作员不能触发 `AuthorizedOperator` 事件。

- 持有者必须允许撤销默认操作员，除非默认操作员本身就是持有者。

- 持有者必须允许重新授权之前的默认操作员。

- 当默认操作员被显示的授权或撤销，需要相应的触发 `AuthorizedOperator` 或 `RevokedOperator` 事件

以下是任何操作员需遵守的规则：


- 每个地址都是其自身的操作员，因此不能被撤销。

- 如果地址是某个持有者的操作员, `isOperatorFor` 返回 `true` ，否则返回 `false` .

- 触发`AuthorizedOperator` 事件，要确保参数正确。参考[`AuthorizedOperator` 事件](#authorizedoperator)

- 触发 `RevokedOperator` 事件，要确保参数正确。参考[`RevokedOperator`  事件](#revokedoperator)
  .

*注意*: 持有者也许会重复授权一个操作员，每次都需要触发`AuthorizedOperator`事件。

*注意*: A 持有者也许会撤销一个操作员，每次都需要触发`RevokedOperator`事件。

**`AuthorizedOperator` 事件** <a id="authorizedoperator"></a>

``` solidity
event AuthorizedOperator(address indexed operator, address indexed holder)
```

Indicates the authorization of `operator` as an 操作员 for `holder`.

*注意*: This event MUST NOT be emitted outside of an 操作员 authorization process.

* 参数：
`operator`: Address which became an 操作员 of `holder`.
`holder`: Address of a 持有者 which authorized the `operator` address as an 操作员.

**`RevokedOperator` 事件** <a id="revokedoperator"></a>

``` solidity
event RevokedOperator(address indexed operator, address indexed holder)
```

Indicates the revocation of `operator` as an 操作员 for `holder`.

*注意*: This event MUST NOT be emitted outside of an 操作员 revocation process.

* 参数：
`operator`: Address which was revoked as an 操作员 of `holder`.
`holder`: Address of a 持有者 which revoked the `operator` address as an 操作员.

The `defaultOperators`, `authorizeOperator`, `revokeOperator` and `isOperatorFor` functions described below
MUST be implemented to manage *operators*.
代币 contracts MAY implement other functions to manage *operators*.

**`defaultOperators` 函数** <a id="defaultOperators"></a>

``` solidity
function defaultOperators() external view returns (address[] memory)
```

Get the list of *default operators* as defined by the 代币合约.

*注意*: If the 代币合约 does not have any *default operators*, this function MUST return an empty list.

* 接口ID: `06e48538`
**returns:** List of addresses of all the *default operators*.

**`authorizeOperator` 函数**

``` solidity
function authorizeOperator(address operator) external
```

Set a third party `operator` address as an 操作员 of `msg.sender` to send and burn tokens on its behalf.

*注意*: The 持有者 (`msg.sender`) is always an 操作员 for itself.
This right SHALL NOT be revoked.
Hence this function MUST `revert` if it is called to authorize the holder (`msg.sender`)
as an 操作员 for itself (i.e. if `operator` is equal to `msg.sender`).

* 接口ID: `959b8c3f`
* 参数：
`operator`: Address to set as an 操作员 for `msg.sender`.

**`revokeOperator` 函数**

``` solidity
function revokeOperator(address operator) external
```

Remove the right of the `operator` address to be an 操作员 for `msg.sender`
and to send and burn tokens on its behalf.

*注意*: The 持有者 (`msg.sender`) is always an 操作员 for itself.
This right SHALL NOT be revoked.
Hence this function MUST `revert` if it is called to revoke the holder (`msg.sender`)
as an 操作员 for itself (i.e., if `operator` is equal to `msg.sender`).

* 接口ID: `fad8b32a`
* 参数：
`operator`: Address to rescind as an 操作员 for `msg.sender`.

**`isOperatorFor` 函数** <a id="isOperatorFor"></a>

``` solidity
function isOperatorFor(
    address operator,
    address holder
) external view returns (bool)
```

Indicate whether the `operator` address is an 操作员 of the `holder` address.

* 接口ID: `d95b6371`
* 参数：
`operator`: Address which may be an 操作员 of `holder`.
`holder`: Address of a 持有者 which may have the `operator` address as an 操作员.
>
**returns:** `true` if `operator` is an 操作员 of `holder` and `false` otherwise.

*注意*: To know which addresses are *operators* for a given 持有者,
one MUST call `isOperatorFor` with the 持有者 for each *default operator*
and parse the `AuthorizedOperator`, and `RevokedOperator` events for the 持有者 in question.

#### **Sending Tokens**

When an 操作员 sends an `amount` of tokens from a 持有者 to a *recipient*
with the associated `data` and `operatorData`, the 代币合约 MUST apply the following rules:

- Any authorized 操作员 MAY send tokens to any *recipient* (except to `0x0`).

- The balance of the 持有者 MUST be decreased by the `amount`.

- The balance of the *recipient* MUST be increased by the `amount`.

- The balance of the 持有者 MUST be greater or equal to the `amount`&mdash;such
  that its resulting balance is greater or equal to zero (`0`) after the send.

- The 代币合约 MUST emit a `Sent` event with the correct values as defined in the [`Sent` Event][sent].

- The 操作员 MAY include information in the `operatorData`.

- The 代币合约 MUST call the `tokensToSend` hook of the 持有者
  if the 持有者 registers an `ERC777TokensSender` implementation via [ERC1820].

- The 代币合约 MUST call the `tokensReceived` hook of the *recipient*
  if the *recipient* registers an `ERC777TokensRecipient` implementation via [ERC1820].

- The `data` and `operatorData` MUST be immutable during the entire send process&mdash;hence
  the same `data` and `operatorData` MUST be used to call both hooks and emit the `Sent` event.

The 代币合约 MUST `revert` when sending in any of the following cases:

- The 操作员 address is not an authorized operator for the 持有者.

- The resulting 持有者 balance or *recipient* balance after the send
  is not a multiple of the *granularity* defined by the 代币合约.

- The *recipient* is a 合约, and it does not implement the `ERC777TokensRecipient` interface via [ERC1820].

- The address of the 持有者 or the *recipient* is `0x0`.

- Any of the resulting balances becomes negative, i.e. becomes less than zero (`0`).

- The `tokensToSend` hook of the 持有者 `revert`s.

- The `tokensReceived` hook of the *recipient* `revert`s.

The 代币合约 MAY send tokens from many *holders*, to many *recipients*, or both. In this case:

- The previous send rules MUST apply to all the *holders* and all the *recipients*.
- The sum of all the balances incremented MUST be equal to the total sent `amount`.
- The sum of all the balances decremented MUST be equal to the total sent `amount`.
- A `Sent` event MUST be emitted for every 持有者 and *recipient* pair with the corresponding amount for each pair.
- The sum of all the amounts from the `Sent` event MUST be equal to the total sent `amount`.

*注意*: Mechanisms such as applying a fee on a send is considered as a send to multiple *recipients*:
the intended *recipient* and the fee *recipient*.

*注意*: Movements of tokens MAY be chained.
For example, if a 合约 upon receiving tokens sends them further to another address.
In this case, the previous send rules apply to each send, in order.

*注意*: Sending an amount of zero (`0`) tokens is valid and MUST be treated as a regular send.

*Implementation Requirement*:
- The 代币合约 MUST call the `tokensToSend` hook *before* updating the state.
- The 代币合约 MUST call the `tokensReceived` hook *after* updating the state.
I.e., `tokensToSend` MUST be called first,
then the balances MUST be updated to reflect the send,
and finally `tokensReceived` MUST be called *afterward*.
Thus a `balanceOf` call within `tokensToSend` returns the balance of the address *before* the send
and a `balanceOf` call within `tokensReceived` returns the balance of the address *after* the send.

*注意*: The `data` field contains information provided by the 持有者&mdash;similar
to the data field in a regular ether send transaction.
The `tokensToSend()` hook, the `tokensReceived()`, or both
MAY use the information to decide if they wish to reject the transaction.

*注意*: The `operatorData` field is analogous to the `data` field except it SHALL be provided by the 操作员.

The `operatorData` MUST only be provided by the 操作员.
It is intended more for logging purposes and particular cases.
(Examples include payment references, cheque numbers, countersignatures and more.)
In most of the cases the recipient would ignore the `operatorData`, or at most, it would log the `operatorData`.

**`Sent` 事件** <a id="sent"></a>

``` solidity
event Sent(
    address indexed operator,
    address indexed from,
    address indexed to,
    uint256 amount,
    bytes data,
    bytes operatorData
)
```

Indicate a send of `amount` of tokens from the `from` address to the `to` address by the `operator` address.

*注意*: This event MUST NOT be emitted outside of a send or an [ERC20] transfer process.

* 参数：
`operator`: Address which triggered the send.
`from`: 持有者 whose tokens were sent.
`to`: Recipient of the tokens.
`amount`: Number of tokens sent.
`data`: Information provided by the 持有者.
`operatorData`: Information provided by the 操作员.

The `send` and `operatorSend` functions described below MUST be implemented to send tokens.
代币 contracts MAY implement other functions to send tokens.

**`send` 函数**

``` solidity
function send(address to, uint256 amount, bytes calldata data) external
```

Send the `amount` of tokens from the address `msg.sender` to the address `to`.

The 操作员 and the 持有者 MUST both be the `msg.sender`.

* 接口ID: `9bd9bbc6`
* 参数：
`to`: Recipient of the tokens.
`amount`: Number of tokens to send.
`data`: Information provided by the 持有者.

**`operatorSend` 函数**

``` solidity
function operatorSend(
    address from,
    address to,
    uint256 amount,
    bytes calldata data,
    bytes calldata operatorData
) external
```

Send the `amount` of tokens on behalf of the address `from` to the address `to`.

*Reminder*: If the 操作员 address is not an authorized operator of the `from` address,
then the send process MUST `revert`.

*注意*: `from` and `msg.sender` MAY be the same address.
I.e., an address MAY call `operatorSend` for itself.
This call MUST be equivalent to `send` with the addition
that the 操作员 MAY specify an explicit value for `operatorData`
(which cannot be done with the `send` function).

* 接口ID: `62ad1b83`
* 参数：
`from`: 持有者 whose tokens are being sent.
`to`: Recipient of the tokens.
`amount`: Number of tokens to send.
`data`: Information provided by the 持有者.
`operatorData`: Information provided by the 操作员.

#### **Minting Tokens**

Minting tokens is the act of producing new tokens.
[ERC777] intentionally does not define specific functions to mint tokens.
This intent comes from the wish not to limit the use of the [ERC777] standard
as the minting process is generally specific for every 代币.

Nonetheless, the rules below MUST be respected when minting for a *recipient*:

- Tokens MAY be minted for any *recipient* address (except `0x0`).

- The total supply MUST be increased by the amount of tokens minted.

- The balance of `0x0` MUST NOT be decreased.

- The balance of the *recipient* MUST be increased by the amount of tokens minted.

- The 代币合约 MUST emit a `Minted` event with the correct values as defined in the [`Minted` Event][minted].

- The 代币合约 MUST call the `tokensReceived` hook of the *recipient*
  if the *recipient* registers an `ERC777TokensRecipient` implementation via [ERC1820].

- The `data` and `operatorData` MUST be immutable during the entire mint process&mdash;hence
  the same `data` and `operatorData` MUST be used to call the `tokensReceived` hook and emit the `Minted` event.

The 代币合约 MUST `revert` when minting in any of the following cases:

- The resulting *recipient* balance after the mint is not a multiple of the *granularity* defined by the 代币合约.
- The *recipient* is a 合约, and it does not implement the `ERC777TokensRecipient` interface via [ERC1820].
- The address of the *recipient* is `0x0`.
- The `tokensReceived` hook of the *recipient* `revert`s.

*注意*: The initial 代币 supply at the creation of the 代币合约 MUST be considered as minting
for the amount of the initial supply to the address(es) receiving the initial supply.
This means one or more `Minted` events must be emitted
and the `tokensReceived` hook of the recipient(s) MUST be called.

*[ERC20] compatibility requirement*:
While a `Sent` event MUST NOT be emitted when minting,
if the 代币合约 is [ERC20] backward compatible,
a `Transfer` event with the `from` parameter set to `0x0` SHOULD be emitted as defined in the [ERC20] standard.

The 代币合约 MAY mint tokens for multiple *recipients* at once. In this case:

- The previous mint rules MUST apply to all the *recipients*.
- The sum of all the balances incremented MUST be equal to the total minted amount.
- A `Minted` event MUST be emitted for every *recipient* with the corresponding amount for each *recipient*.
- The sum of all the amounts from the `Minted` event MUST be equal to the total minted `amount`.

*注意*: Minting an amount of zero (`0`) tokens is valid and MUST be treated as a regular mint.

*注意*: While during a send or a burn, the data is provided by the 持有者, it is inapplicable for a mint.
In this case the data MAY be provided by the 代币合约 or the 操作员,
for example to ensure a successful minting to a 持有者 expecting specific data.

*注意*: The `operatorData` field contains information provided by the 操作员&mdash;similar
to the data field in a regular ether send transaction.
The `tokensReceived()` hooks MAY use the information to decide if it wish to reject the transaction.

**`Minted` 事件** <a id="minted"></a>

``` solidity
event Minted(
    address indexed operator,
    address indexed to,
    uint256 amount,
    bytes data,
    bytes operatorData
)
```

Indicate the minting of `amount` of tokens to the `to` address by the `operator` address.

*注意*: This event MUST NOT be emitted outside of a mint process.

* 参数：
`operator`: Address which triggered the mint.
`to`: Recipient of the tokens.
`amount`: Number of tokens minted.
`data`: Information provided for the *recipient*.
`operatorData`: Information provided by the 操作员.

#### **Burning Tokens**

Burning tokens is the act of destroying existing tokens.
[ERC777] explicitly defines two functions to burn tokens (`burn` and `operatorBurn`).
These functions facilitate the integration of the burning process in wallets and dapps.
However, the 代币合约 MAY prevent some or all *holders* from burning tokens for any reason.
The 代币合约 MAY also define other functions to burn tokens.

The rules below MUST be respected when burning the tokens of a 持有者:

- Tokens MAY be burned from any 持有者 address (except `0x0`).

- The total supply MUST be decreased by the amount of tokens burned.

- The balance of `0x0` MUST NOT be increased.

- The balance of the 持有者 MUST be decreased by amount of tokens burned.

- The 代币合约 MUST emit a `Burned` event with the correct values as defined in the [`Burned` Event][burned].

- The 代币合约 MUST call the `tokensToSend` hook of the 持有者
  if the 持有者 registers an `ERC777TokensSender` implementation via [ERC1820].

- The `operatorData` MUST be immutable during the entire burn process&mdash;hence
  the same `operatorData` MUST be used to call the `tokensToSend` hook and emit the `Burned` event.

The 代币合约 MUST `revert` when burning in any of the following cases:

- The 操作员 address is not an authorized operator for the 持有者.

- The resulting 持有者 balance after the burn is not a multiple of the *granularity*
  defined by the 代币合约.

- The balance of 持有者 is inferior to the amount of tokens to burn
  (i.e., resulting in a negative balance for the 持有者).

- The address of the 持有者 is `0x0`.

- The `tokensToSend` hook of the 持有者 `revert`s.

*[ERC20] compatibility requirement*:
While a `Sent` event MUST NOT be emitted when burning;
if the 代币合约 is [ERC20] enabled, a `Transfer` event with the `to` parameter set to `0x0` SHOULD be emitted.
The [ERC20] standard does not define the concept of burning tokens, but this is a commonly accepted practice.

The 代币合约 MAY burn tokens for multiple *holders* at once. In this case:

- The previous burn rules MUST apply to each *holders*.
- The sum of all the balances decremented MUST be equal to the total burned amount.
- A `Burned` event MUST be emitted for every 持有者 with the corresponding amount for each 持有者.
- The sum of all the amounts from the `Burned` event MUST be equal to the total burned `amount`.

*注意*: Burning an amount of zero (`0`) tokens is valid and MUST be treated as a regular burn.

*注意*: The `data` field contains information provided by the holder&mdash;similar
to the data field in a regular ether send transaction.
The `tokensToSend()` hook, the `tokensReceived()`, or both
MAY use the information to decide if they wish to reject the transaction.

*注意*: The `operatorData` field is analogous to the `data` field except it SHALL be provided by the 操作员.

**`Burned` 事件** <a id="burned"></a>

``` solidity
event Burned(
    ddress indexed operator,
    address indexed from,
    uint256 amount,
    bytes data,
    bytes operatorData
);
```

Indicate the burning of `amount` of tokens from the `from` address by the `operator` address.

*注意*: This event MUST NOT be emitted outside of a burn process.

* 参数：
`operator`: Address which triggered the burn.
`from`: 持有者 whose tokens were burned.
`amount`: Number of tokens burned.
`data`: Information provided by the 持有者.
`operatorData`: Information provided by the 操作员.

The `burn` and `operatorBurn` functions described below MUST be implemented to burn tokens.
代币 contracts MAY implement other functions to burn tokens.

**`burn` 函数**

``` solidity
function burn(uint256 amount, bytes calldata data) external
```

Burn the `amount` of tokens from the address `msg.sender`.

The 操作员 and the 持有者 MUST both be the `msg.sender`.

* 接口ID: `fe9d9303`
* 参数：
  * `amount`: Number of tokens to burn.
  * `data`: Information provided by the 持有者.

**`operatorBurn` 函数**

``` solidity
function operatorBurn(
    address from,
    uint256 amount,
    bytes calldata data,
    bytes calldata operatorData
) external
```

Burn the `amount` of tokens on behalf of the address `from`.

*Reminder*: If the 操作员 address is not an authorized operator of the `from` address,
then the burn process MUST `revert`.

* 接口ID: `fc673c4f`
* 参数：
`from`: 持有者 whose tokens will be burned.
`amount`: Number of tokens to burn.
`data`: Information provided by the 持有者.
`operatorData`: Information provided by the 操作员.

*注意*: The 操作员 MAY pass any information via `operatorData`.
The `operatorData` MUST only be provided by the 操作员.

*注意*: `from` and `msg.sender` MAY be the same address.
I.e., an address MAY call `operatorBurn` for itself.
This call MUST be equivalent to `burn`
with the addition that the 操作员 MAY specify an explicit value for `operatorData`
(which cannot be done with the `burn` function).

#### **`ERC777TokensSender` And The `tokensToSend` Hook**

The `tokensToSend` hook notifies of any request to decrement the balance (send and burn) for a given 持有者.
Any address (regular or 合约) wishing to be notified of 代币 debits from their address
MAY register the address of a 合约 implementing the `ERC777TokensSender` interface described below via [ERC1820].

> This is done by calling the `setInterfaceImplementer` function on the [ERC1820] registry
> with the 持有者 address as the address,
> the `keccak256` hash of `ERC777TokensSender`
> (`0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895`) as the interface hash,
> and the address of the 合约 implementing the `ERC777TokensSender` as the implementer.

``` solidity
interface ERC777TokensSender {
    function tokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}
```

*注意*: A regular address MAY register a different address&mdash;the address of a 合约&mdash;implementing
the interface on its behalf.
A 合约 MAY register either its address or the address of another 合约
but said address MUST implement the interface on its behalf.

**`tokensToSend`**

``` solidity
function tokensToSend(
    address operator,
    address from,
    address to,
    uint256 amount,
    bytes calldata userData,
    bytes calldata operatorData
) external
```

Notify a request to send or burn (if `to` is `0x0`) an `amount` tokens from the `from` address to the `to` address
by the `operator` address.

*注意*: This function MUST NOT be called outside of a burn, send or [ERC20] transfer process.

* 接口ID: `75ab9782`
* 参数：
`operator`: Address which triggered the balance decrease (through sending or burning).
`from`: 持有者 whose tokens were sent.
`to`: Recipient of the tokens for a send (or `0x0` for a burn).
`amount`: Number of tokens the 持有者 balance is decreased by.
`data`: Information provided by the 持有者.
`operatorData`: Information provided by the 操作员.

The following rules apply when calling the `tokensToSend` hook:

- The `tokensToSend` hook MUST be called for every send and burn processes.

- The `tokensToSend` hook MUST be called *before* the state is updated&mdash;i.e. *before* the balance is decremented.

- `operator` MUST be the address which triggered the send or burn process.

- `from` MUST be the address of the 持有者 whose tokens are sent or burned.

- `to` MUST be the address of the *recipient* which receives the tokens for a send.

- `to` MUST be `0x0` for a burn.

- `amount` MUST be the number of tokens the 持有者 sent or burned.

- `data` MUST contain the extra information (if any) provided to the send or the burn process.

- `operatorData` MUST contain the extra information provided by the address
  which triggered the decrease of the balance (if any).

- The 持有者 MAY block a send or burn process by `revert`ing.
  (I.e., reject the withdrawal of tokens from its account.)

*注意*: Multiple *holders* MAY use the same implementation of `ERC777TokensSender`.

*注意*: An address can register at most one implementation at any given time for all [ERC777] tokens.
Hence the `ERC777TokensSender` MUST expect to be called by different 代币 contracts.
The `msg.sender` of the `tokensToSend` call is expected to be the address of the 代币合约.

*[ERC20] compatibility requirement*:
This hook takes precedence over [ERC20] and MUST be called (if registered)
when calling [ERC20]'s `transfer` and `transferFrom` event.
When called from a `transfer`, `operator` MUST be the same value as the `from`.
When called from a `transferFrom`, `operator` MUST be the address which issued the `transferFrom` call.

#### **`ERC777TokensRecipient` And The `tokensReceived` Hook**

The `tokensReceived` hook notifies of any increment of the balance (send and mint) for a given *recipient*.
Any address (regular or 合约) wishing to be notified of 代币 credits to their address
MAY register the address of a 合约 implementing the `ERC777TokensSender` interface described below via [ERC1820].

> This is done by calling the `setInterfaceImplementer` function on the [ERC1820] registry
> with the *recipient* address as the address,
> the `keccak256` hash of `ERC777TokensRecipient`
> (`0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b`) as the interface hash,
> and the address of the 合约 implementing the `ERC777TokensRecipient` as the implementer.

``` solidity
interface ERC777TokensRecipient {
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata data,
        bytes calldata operatorData
    ) external;
}
```

If the *recipient* is a 合约, which has not registered an `ERC777TokensRecipient` implementation;
then the 代币合约:

- MUST `revert` if the `tokensReceived` hook is called from a mint or send call.

- SHOULD continue processing the transaction
  if the `tokensReceived` hook is called from an ERC20 `transfer` or `transferFrom` call.

*注意*: A regular address MAY register a different address&mdash;the address of a 合约&mdash;implementing
the interface on its behalf.
A 合约 MUST register either its address or the address of another 合约
but said address MUST implement the interface on its behalf.

**`tokensReceived`**

``` solidity
function tokensReceived(
    address operator,
    address from,
    address to,
    uint256 amount,
    bytes calldata data,
    bytes calldata operatorData
) external
```

Notify a send or mint (if `from` is `0x0`) of `amount` tokens from the `from` address to the `to` address
by the `operator` address.

*注意*: This function MUST NOT be called outside of a mint, send or [ERC20] transfer process.

* 接口ID: `0023de29`
* 参数：
  `operator`: Address which triggered the balance increase (through sending or minting).
  `from`: 持有者 whose tokens were sent (or `0x0` for a mint).
  `to`: Recipient of the tokens.
  `amount`: Number of tokens the *recipient* balance is increased by.
  `data`: Information provided by the 持有者.
  `operatorData`: Information provided by the 操作员.

The following rules apply when calling the `tokensReceived` hook:

- The `tokensReceived` hook MUST be called for every send and mint processes.

- The `tokensReceived` hook MUST be called *after* the state is updated&mdash;i.e. *after* the balance is incremented.

- `operator` MUST be the address which triggered the send or mint process.

- `from` MUST be the address of the 持有者 whose tokens are sent for a send.

- `from` MUST be `0x0` for a mint.

- `to` MUST be the address of the *recipient* which receives the tokens.

- `amount` MUST be the number of tokens the *recipient* sent or minted.

- `data` MUST contain the extra information (if any) provided to the send or the mint process.

- `operatorData` MUST contain the extra information provided by the address
  which triggered the increase of the balance (if any).

- The 持有者 MAY block a send or mint process by `revert`ing.
  (I.e., reject the reception of tokens.)

*注意*: Multiple *holders* MAY use the same implementation of `ERC777TokensRecipient`.

*注意*: An address can register at most one implementation at any given time for all [ERC777] tokens.
Hence the `ERC777TokensRecipient` MUST expect to be called by different 代币 contracts.
The `msg.sender` of the `tokensReceived` call is expected to be the address of the 代币合约.

*[ERC20] compatibility requirement*:
This hook takes precedence over [ERC20] and MUST be called (if registered)
when calling [ERC20]'s `transfer` and `transferFrom` event.
When called from a `transfer`, `operator` MUST be the same value as the `from`.
When called from a `transferFrom`, `operator` MUST be the address which issued the `transferFrom` call.

#### **Note On Gas Consumption**

Dapps and wallets SHOULD first estimate the gas required when sending, minting, or burning tokens&mdash;using
[`eth_estimateGas`][eth_estimateGas]&mdash;to avoid running out of gas during the transaction.

### Logo

| **Image** | ![beige logo] | ![white logo] | ![light grey logo] | ![dark grey logo] | ![black logo] |
|----------:|:-------------:|:-------------:|:------------------:|:-----------------:|:-------------:|
| **Color** | beige         | white         | light grey         | dark grey         | black         |
| **Hex**   | `#C99D66`     | `#FFFFFF`     | `#EBEFF0`          | `#3C3C3D`         | `#000000`     |

The logo MAY be used, modified and adapted to promote valid [ERC777] 代币 implementations
and [ERC777] compliant technologies such as wallets and dapps.

[ERC777] 代币合约 authors MAY create a specific logo for their 代币 based on this logo.

The logo MUST NOT be used to advertise, promote or associate in any way technology&mdash;such
as tokens&mdash;which is not [ERC777] compliant.

The logo for the standard can be found in the [`/assets/eip-777/logo`][logos] folder in `SVG` and `PNG` formats.
The `PNG` version of the logo offers a few sizes in pixels.
If needed, other sizes MAY be created by converting from `SVG` into `PNG`.

## 原理阐述

The principal intent for this standard is
to solve some of the shortcomings of [ERC20] while maintaining backward compatibility with [ERC20],
and avoiding the problems and vulnerabilities of [EIP223].

Below are the rationales for the decisions regarding the main aspects of the standards.

*注意*: Jacques Dafflon ([0xjac]), one of the authors of the standard,
conjointly wrote his [master thesis] on the standard,
which goes in more details than could reasonably fit directly within the standard,
and can provide further clarifications regarding certain aspects or decisions.

### Lifecycle

More than just sending tokens, [ERC777] defines the entire lifecycle of a 代币,
starting with the minting process, followed by the sending process and terminating with the burn process.

Having a lifecycle clearly defined is important for consistency and accuracy,
especially when value is derived from scarcity.
In contrast when looking at some [ERC20] tokens, a discrepancy can be observed
between the value returned by the `totalSupply` and the actual circulating supply,
as the standard does not clearly define a process to create and destroy tokens.

### Data

The mint, send and burn processes can all make use of a `data` and `operatorData` fields
which are passed to any movement (mint, send or burn).
Those fields may be empty for simple use cases,
or they may contain valuable information related to the movement of tokens,
similar to information attached to a bank transfer by the sender or the bank itself.

The use of a `data` field is equally present in other standard proposals such as [EIP223],
and was requested by multiple members of the community who reviewed this standard.

### Hooks

In most cases, [ERC20] requires two calls to safely transfer tokens to a 合约 without locking them.
A call from the sender, using the `approve` function
and a call from the recipient using `transferFrom`.
Furthermore, this requires extra communication between the parties which is not clearly defined.
Finally, holders can get confused between `transfer` and `approve`/`transferFrom`.
Using the former to transfer tokens to a 合约 will most likely result in locked tokens.

Hooks allow streamlining of the sending process and offer a single way to send tokens to any recipient.
Thanks to the `tokensReceived` hook, contracts are able to react and prevent locking tokens upon reception.

#### **Greater Control For Holders**

The `tokensReceived` hook also allows holders to reject the reception of some tokens.
This gives greater control to holders who can accept or reject incoming tokens based on some parameters,
for example located in the `data` or `operatorData` fields.

Following the same intentions and based on suggestions from the community,
the `tokensToSend` hook was added to give control over and prevent the movement of outgoing tokens.

#### **[ERC1820] 注册表合约**

The [ERC1820] 注册表合约 allows holders to register their hooks.
Other alternatives were examined beforehand to link hooks and holders.

The first was for hooks to be defined at the sender's or recipient's address.
This approach is similar to [EIP223] which proposes a `tokenFallback` function on recipient contracts
to be called when receiving tokens,
but improves on it by relying on [ERC165] for interface detection.
While straightforward to implement, this approach imposes several limitations.
In particular, the sender and recipient must be contracts in order to provide their implementation of the hooks.
Preventing externally owned addresses to benefit from hooks.
Existing contracts have a strong probability not to be compatible,
as they undoubtedly were unaware and do not define the new hooks.
Consequently existing smart 合约 infrastructure such as multisig wallets
which potentially hold large amounts of ether and tokens would need to be migrated to new updated contracts.

The second approach considered was to use [ERC672] which offered pseudo-introspection for addresses using reverse-ENS.
However, this approach relied heavily on ENS, on top of which reverse lookup would need to be implemented.
Analysis of this approach promptly revealed a certain degree of complexity and security concerns
which would transcend the benefits of approach.

The third solution&mdash;used in this standard&mdash;is to rely on a unique 注册表合约
where any address can register the addresses of contracts implementing the hooks on its behalf.
This approach has the advantage that externally owned accounts and contracts can benefit from hooks,
including existing contracts which can rely on hooks deployed on proxy contracts.

The decision was made to keep this registry in a separate EIP,
as to not over complicate this standard.
More importantly, the registry is designed in a flexible fashion,
such that other EIPs and smart 合约 infrastructures can benefit from it
for their own use cases, outside the realm of [ERC777] and tokens.
The first proposal for this registry was [ERC820].
Unfortunately, issues emanating from upgrades in the Solidity language to versions 0.5 and above
resulted in a bug in a separated part of the registry, which required changes.
This was discovered right after the last call period.
Attempts made to avoid creating a separate EIP, such as [ERC820a], were rejected.
Hence the standard for the registry used for [ERC777] became [ERC1820].
[ERC1820] and [ERC820] are functionally equivalent. [ERC1820] simply contains the fix for newer versions of Solidity.

### Operators

The standard defines the concept of operators as any address which moves tokens.
While intuitively every address moves its own tokens,
separating the concepts of holder and operator allows for greater flexibility.
Primarily, this originates from the fact that the standard defines a mechanism for holders
to let other addresses become their operators.
Moreover, unlike the approve calls in [ERC20] where the role of an approved address is not clearly defined,
[ERC777] details the intent of and interactions with operators,
including an obligation for operators to be approved,
and an irrevocable right for any holder to revoke operators.

#### **Default Operators**

Default operators were added based on community demand for pre-approved operators.
That is operators which are approved for all holders by default.
For obvious security reasons, the list of default operators is defined at the 代币合约 creation time,
and cannot be changed.
Any holder still has the right to revoke default operators.
One of the obvious advantages of default operators is to allow ether-less movements of tokens.
Default operators offer other usability advantages,
such as allowing 代币 providers to offer functionality in a modular way,
and to reduce the complexity for holders to use features provided through operators.

## Backward Compatibility

This EIP does not introduce backward incompatibilities and is backward compatible with the older [ERC20] 代币 standard.

This EIP does not use `transfer` and `transferFrom` and uses `send` and `operatorSend`
to avoid confusion and mistakes when deciphering which 代币 standard is being used.

This standard allows the implementation of [ERC20] functions `transfer`, `transferFrom`, `approve` and `allowance`
alongside to make a 代币 fully compatible with [ERC20].

The 代币 MAY implement `decimals()` for backward compatibility with [ERC20].
If implemented, it MUST always return `18`.

Therefore a 代币合约 MAY implement both [ERC20] and [ERC777] in parallel.
The specification of the `view` functions (such as `name`, `symbol`, `balanceOf`, `totalSupply`) and internal data
(such as the mapping of balances) overlap without problems.
Note however that the following functions are mandatory in [ERC777] and MUST be implemented:
`name`, `symbol` `balanceOf` and `totalSupply`
(`decimals` is not part of the [ERC777] standard).

The state-modifying functions from both standards are decoupled and can operate independently from each other.
Note that [ERC20] functions SHOULD be limited to only being called from old contracts.

If the 代币 implements [ERC20],
it MUST register the `ERC20Token` interface with its own address via [ERC1820].
This is done by calling the `setInterfaceImplementer` function on the ERC1820 registry
with the 代币合约 address as both the address and the implementer
and the `keccak256` hash of `ERC20Token` (`0xaea199e31a596269b42cdafd93407f14436db6e4cad65417994c2eb37381e05a`)
as the interface hash.

If the 合约 has a switch to enable or disable ERC20 functions, every time the switch is triggered,
the 代币 MUST register or unregister the `ERC20Token` interface for its own address accordingly via ERC1820.
Unregistering implies calling the `setInterfaceImplementer` with the 代币合约 address as the address,
the `keccak256` hash of `ERC20Token` as the interface hash and `0x0` as the implementer.
(See [Set An Interface For An Address][erc1820-set] in [ERC1820] for more details.)

The difference for new contracts implementing [ERC20] is that
`tokensToSend` and `tokensReceived` hooks take precedence over [ERC20].
Even with an [ERC20] `transfer` and `transferFrom` call, the 代币合约 MUST check via [ERC1820]
if the `from` and the `to` address implement `tokensToSend` and `tokensReceived` hook respectively.
If any hook is implemented, it MUST be called.
Note that when calling [ERC20] `transfer` on a 合约, if the 合约 does not implement `tokensReceived`,
the `transfer` call SHOULD still be accepted even if this means the tokens will probably be locked.

The table below summarizes the different actions the 代币合约 MUST take
when sending, minting and transferring 代币 via [ERC777] and [ERC20]:

<table>
  <tr>
    <th align="right">ERC1820</th>
    <th><code>to</code> address</th>
    <th align="center">ERC777 Sending And Minting</th>
    <th align="center">ERC20 <code>transfer</code>/<code>transferFrom</code></th>
  </tr>
  <tr>
    <td rowspan="2" align="right">
      <code>ERC777TokensRecipient</code><br/>registered
    </td>
    <td>regular address</td>
    <td colspan="2" rowspan="2" align="center">
      MUST call <code>tokensReceived</code>
    </td>
  </tr>
  <tr>
    <td>合约</td>
  </tr>
  <tr>
    <td rowspan="2" align="right">
      <code>ERC777TokensRecipient</code><br/>not registered
    </td>
    <td>regular address</td>
    <td colspan="2" align="center">continue</td>
  </tr>
  <tr>
    <td>合约</td>
    <td align="center">MUST <code>revert</code></td>
    <td align="center">SHOULD continue<sup><a id="continue-footnote-backlink" href="#continue-footnote">1</a></sup></td>
  </tr>
</table>

> <a href="#continue-footnote-backlink"><small id="continue-footnote">1.</a>
The transaction SHOULD continue for clarity as ERC20 is not aware of hooks.
However, this can result in accidentally locked tokens.
If avoiding accidentally locked tokens is paramount, the transaction MAY <code>revert</code>.


There is no particular action to take if `tokensToSend` is not implemented.
The movement MUST proceed and only be canceled if another condition is not respected
such as lack of funds or a `revert` in `tokensReceived` (if present).

During a send, mint and burn, the respective `Sent`, `Minted` and `Burned` events MUST be emitted.
Furthermore, if the 代币合约 declares that it implements `ERC20Token` via [ERC1820],
the 代币合约 SHOULD emit a `Transfer` event for minting and burning
and MUST emit a `Transfer` event for sending (as specified in the [ERC20] standard).
During an [ERC20]'s `transfer` or `transferFrom` functions, a valid `Sent` event MUST be emitted.

Hence for any movement of tokens, two events MAY be emitted:
an [ERC20] `Transfer` and an [ERC777] `Sent`, `Minted` or `Burned` (depending on the type of movement).
Third-party developers MUST be careful not to consider both events as separate movements.
As a general rule, if an application considers the 代币 as an ERC20 代币,
then only the `Transfer` event MUST be taken into account.
If the application considers the 代币 as an ERC777 代币,
then only the `Sent`, `Minted` and `Burned` events MUST be considered.

## 测试用例

The [repository with the reference implementation][0xjac/ERC777] contains all the [tests][ref tests].

## 实现

The GitHub repository [0xjac/ERC777] contains the [reference implementation].
The reference implementation is also available via [npm][npm/erc777] and can be installed with `npm install erc777`.

## 版权

Copyright and related rights waived via [CC0].

[operators]: #operators

[ERC20]: https://learnblockchain.cn/docs/eips/eip-20.html
[ERC165]: https://learnblockchain.cn/docs/eips/eip-165.html
[ERC672]: https://github.com/ethereum/EIPs/issues/672
[ERC777]: https://learnblockchain.cn/docs/eips/eip-777.html
[ERC820]: https://learnblockchain.cn/docs/eips/eip-820.html
[ERC820a]: https://github.com/ethereum/EIPs/pull/1758
[ERC1820]: https://learnblockchain.cn/docs/eips/eip-1820.html
[erc1820-set]: https://learnblockchain.cn/docs/eips/eip-1820.html#为接口设置实现地址
[0xjac]: https://github.com/0xjac
[0xjac/ERC777]: https://github.com/0xjac/ERC777
[master thesis]: https://github.com/0xjac/master-thesis
[npm/erc777]: https://www.npmjs.com/package/erc777
[ref tests]: https://github.com/0xjac/ERC777/blob/master/test/ReferenceToken.test.js
[reference implementation]: https://github.com/0xjac/ERC777/blob/master/contracts/examples/ReferenceToken.sol
[EIP223]: https://github.com/ethereum/EIPs/issues/223
[eth_estimateGas]: https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_estimategas

[authorizedoperator]: #authorizedoperator
[revokedoperator]: #revokedoperator
[isOperatorFor]: #isOperatorFor
[defaultOperators]: #defaultOperators
[sent]: #sent
[minted]: #minted
[burned]: #burned

[logos]: https://github.com/ethereum/EIPs/tree/master/assets/eip-777/logo
[beige logo]: ../assets/eip-777/logo/png/ERC-777-logo-beige-48px.png
[white logo]: ../assets/eip-777/logo/png/ERC-777-logo-white-48px.png
[light grey logo]: ../assets/eip-777/logo/png/ERC-777-logo-light_grey-48px.png
[dark grey logo]: ../assets/eip-777/logo/png/ERC-777-logo-dark_grey-48px.png
[black logo]: ../assets/eip-777/logo/png/ERC-777-logo-black-48px.png

[CC0]: https://creativecommons.org/publicdomain/zero/1.0/
